/**
 * DecisionCards Component
 * 
 * PURPOSE:
 * Displays the compressed decision cards generated by the Decision Engine.
 * Each card bundles multiple micro-decisions into one actionable block.
 * 
 * FEATURES:
 * - Visual cards with emoji, title, and items
 * - "Why" explanation showing ShadowMe's reasoning
 * - Duration estimate
 * - Interactive Accept/Override/Ignore buttons
 * - Accept All button for high cognitive load
 * - Animations and visual feedback
 * - Theme-aware (dark/light mode support)
 */

import { useState, useEffect } from 'react';
import { useAuth } from '../context/AuthContext';
import { useTheme } from '../context/ThemeContext';
import { planApi, feedbackApi, decisionsApi } from '../lib/api';
import { ShadowMascot } from './ShadowMascot';
import { useToast } from './Toast';
import { useConfetti } from './Confetti';
import { sounds } from '../lib/sounds';

export const DecisionCards = ({ onFeedbackComplete }) => {
    const { user } = useAuth();
    const { currentTheme, isDark } = useTheme();
    const toast = useToast();
    const triggerConfetti = useConfetti();
    
    const [plan, setPlan] = useState(null);
    const [loading, setLoading] = useState(true);
    const [generating, setGenerating] = useState(false);
    const [error, setError] = useState(null);
    
    // Track card states (completed, pending)
    const [cardStates, setCardStates] = useState({});
    
    // Override modal state
    const [showOverrideModal, setShowOverrideModal] = useState(false);
    const [overrideCard, setOverrideCard] = useState(null);
    const [alternatives, setAlternatives] = useState([]);
    const [selectedAlternative, setSelectedAlternative] = useState(null);

    // Fetch today's plan on mount
    useEffect(() => {
        if (user?.id) {
            fetchTodayPlan();
        }
    }, [user?.id]);

    const fetchTodayPlan = async () => {
        try {
            setLoading(true);
            const data = await planApi.getToday(user.id);
            setPlan(data.plan);
            
            // Initialize card states
            if (data.plan?.compressed_decision_cards) {
                const states = {};
                data.plan.compressed_decision_cards.forEach(card => {
                    states[card.id] = { status: 'pending', action: null };
                });
                setCardStates(states);
            }
            
            setError(null);
        } catch (err) {
            console.error('Failed to fetch plan:', err);
            setError('Could not load today\'s plan');
        } finally {
            setLoading(false);
        }
    };

    const handleGeneratePlan = async (force = false) => {
        try {
            setGenerating(true);
            setError(null);
            sounds.generate(); // Play generation sound
            
            const endpoint = force ? '/plan/generate?force=true' : '/plan/generate';
            const response = await fetch(`http://localhost:5000${endpoint}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-user-id': user.id,
                },
            });
            const data = await response.json();
            
            if (data.plan) {
                setPlan(data.plan);
                // Initialize card states
                const states = {};
                data.plan.compressed_decision_cards?.forEach(card => {
                    states[card.id] = { status: 'pending', action: null };
                });
                setCardStates(states);
                sounds.success();
                toast.shadow(`Plan ready! ${data.plan.compressed_decision_cards?.length || 0} cards for you`);
            } else {
                setError(data.message || 'No plan generated');
                sounds.error();
            }
        } catch (err) {
            console.error('Failed to generate plan:', err);
            setError('Could not generate plan. Do you have any active decisions?');
            sounds.error();
            toast.error('Could not generate plan');
        } finally {
            setGenerating(false);
        }
    };

    // Handle Accept action
    const handleAccept = async (card) => {
        try {
            sounds.accept(); // Play accept sound
            
            // Send feedback to backend
            await feedbackApi.submit(user.id, {
                plan_id: plan.id,
                item_type: 'card',
                item_id: card.id,
                item_value: card.title,
                action: 'accept',
                rating: 1,
                context: {
                    cognitive_load: plan.cognitive_load,
                    autonomy_level: plan.autonomy_level,
                    card_items: card.items?.map(i => i.decision?.title || i.action),
                }
            });
            
            // Update card state with animation
            setCardStates(prev => {
                const newStates = {
                    ...prev,
                    [card.id]: { status: 'completed', action: 'accept' }
                };
                
                // Check if all cards are now completed for celebration
                const allCompleted = Object.values(newStates).every(s => s.status === 'completed');
                if (allCompleted) {
                    setTimeout(() => {
                        sounds.celebrate();
                        triggerConfetti();
                        toast.celebrate('All done! Your shadow is learning! üéâ');
                    }, 300);
                }
                
                return newStates;
            });
            
            toast.success('Accepted! Shadow is learning...');
            
            // Notify parent
            onFeedbackComplete?.('accept', card);
            
        } catch (err) {
            console.error('Failed to submit accept:', err);
            setError('Failed to record feedback');
            sounds.error();
            toast.error('Failed to accept');
        }
    };

    // Handle Override action - show modal with alternatives
    const handleOverride = async (card) => {
        setOverrideCard(card);
        
        // Fetch alternative decisions
        try {
            const data = await decisionsApi.list(user.id, { active: true });
            const allDecisions = data.decisions || [];
            
            // Filter out decisions already in this card
            const cardDecisionIds = card.items?.map(i => i.decision?.id).filter(Boolean);
            const availableAlternatives = allDecisions.filter(d => 
                !cardDecisionIds.includes(d.id)
            );
            
            setAlternatives(availableAlternatives);
            setShowOverrideModal(true);
        } catch (err) {
            console.error('Failed to fetch alternatives:', err);
        }
    };

    // Confirm override selection
    const confirmOverride = async () => {
        if (!selectedAlternative || !overrideCard) return;
        
        try {
            sounds.override(); // Play override sound
            
            await feedbackApi.submit(user.id, {
                plan_id: plan.id,
                item_type: 'card',
                item_id: overrideCard.id,
                item_value: overrideCard.title,
                action: 'override',
                override_value: selectedAlternative.title,
                rating: 0,
                context: {
                    cognitive_load: plan.cognitive_load,
                    original_items: overrideCard.items?.map(i => i.decision?.title || i.action),
                    chosen_alternative: selectedAlternative.id,
                }
            });
            
            // Update card state
            setCardStates(prev => {
                const newStates = {
                    ...prev,
                    [overrideCard.id]: { 
                        status: 'completed', 
                        action: 'override',
                        alternative: selectedAlternative.title
                    }
                };
                
                // Check if all cards are now completed for celebration
                const allCompleted = Object.values(newStates).every(s => s.status === 'completed');
                if (allCompleted) {
                    setTimeout(() => {
                        sounds.celebrate();
                        triggerConfetti();
                        toast.celebrate('All done! Your preferences are noted! üéâ');
                    }, 300);
                }
                
                return newStates;
            });
            
            // Close modal
            setShowOverrideModal(false);
            setOverrideCard(null);
            setSelectedAlternative(null);
            
            toast.success(`Switched to: ${selectedAlternative.title}`);
            onFeedbackComplete?.('override', overrideCard);
            
        } catch (err) {
            console.error('Failed to submit override:', err);
            setError('Failed to record feedback');
            sounds.error();
            toast.error('Failed to override');
        }
    };

    // Handle Ignore/Skip action
    const handleIgnore = async (card) => {
        try {
            sounds.ignore(); // Play ignore sound
            
            await feedbackApi.submit(user.id, {
                plan_id: plan.id,
                item_type: 'card',
                item_id: card.id,
                item_value: card.title,
                action: 'ignore',
                rating: -1,
                context: {
                    cognitive_load: plan.cognitive_load,
                }
            });
            
            // Update card state
            setCardStates(prev => {
                const newStates = {
                    ...prev,
                    [card.id]: { status: 'completed', action: 'ignore' }
                };
                
                // Check if all cards are now completed
                const allCompleted = Object.values(newStates).every(s => s.status === 'completed');
                if (allCompleted) {
                    setTimeout(() => {
                        sounds.celebrate();
                        triggerConfetti();
                        toast.celebrate('All done for now! üéâ');
                    }, 300);
                }
                
                return newStates;
            });
            
            toast.shadow('Skipped. Shadow will remember.');
            onFeedbackComplete?.('ignore', card);
            
        } catch (err) {
            console.error('Failed to submit ignore:', err);
            setError('Failed to record feedback');
            sounds.error();
        }
    };

    // Handle Accept All
    const handleAcceptAll = async () => {
        const pendingCards = cards.filter(c => cardStates[c.id]?.status === 'pending');
        
        for (const card of pendingCards) {
            await handleAccept(card);
        }
    };

    // Get priority color
    const getPriorityColor = (priority) => {
        switch (priority) {
            case 'high': return '#EF4444';
            case 'medium': return '#F59E0B';
            case 'low': return '#10B981';
            default: return '#6B7280';
        }
    };

    // Theme-aware styles
    const themedContainer = {
        ...styles.container,
        backgroundColor: currentTheme.cardBg,
        boxShadow: currentTheme.shadow,
    };
    
    const themedTitle = {
        ...styles.title,
        color: currentTheme.textPrimary,
    };

    // Get card style based on state
    const getCardStyle = (card) => {
        const state = cardStates[card.id];
        const baseCard = {
            ...styles.card,
            backgroundColor: isDark ? currentTheme.backgroundSecondary : 'white',
            borderColor: currentTheme.border,
        };
        
        if (!state || state.status === 'pending') {
            return {
                ...baseCard,
                borderLeftColor: getPriorityColor(card.priority),
            };
        }
        
        // Completed states
        if (state.action === 'accept') {
            return {
                ...baseCard,
                ...styles.cardCompleted,
                borderLeftColor: '#10B981',
                backgroundColor: isDark ? '#065F4622' : '#F0FDF4',
            };
        }
        if (state.action === 'override') {
            return {
                ...baseCard,
                ...styles.cardCompleted,
                borderLeftColor: '#F59E0B',
                backgroundColor: isDark ? '#78350F22' : '#FFFBEB',
            };
        }
        if (state.action === 'ignore') {
            return {
                ...baseCard,
                ...styles.cardCompleted,
                borderLeftColor: '#9CA3AF',
                backgroundColor: isDark ? currentTheme.backgroundSecondary : '#F3F4F6',
                opacity: 0.7,
            };
        }
        
        return baseCard;
    };

    // Loading state
    if (loading) {
        return (
            <div style={themedContainer}>
                <h3 style={themedTitle}>Today's Plan</h3>
                <div style={styles.loadingCard}>
                    <ShadowMascot state="thinking" message="Loading your plan..." size="medium" />
                </div>
            </div>
        );
    }

    // No plan yet
    if (!plan) {
        return (
            <div style={themedContainer}>
                <h3 style={themedTitle}>Today's Plan</h3>
                {error && <p style={styles.error}>{error}</p>}
                <div style={styles.emptyState}>
                    <ShadowMascot 
                        state={generating ? "thinking" : "idle"} 
                        message={generating ? "Creating your plan..." : "Ready when you are!"} 
                        size="medium" 
                    />
                    <p style={{...styles.emptyText, color: currentTheme.textPrimary}}>
                        {generating ? 'Analyzing your decisions...' : 'No plan generated yet'}
                    </p>
                    <p style={{...styles.emptyHint, color: currentTheme.textMuted}}>
                        {generating ? 'This will only take a moment' : 'Click below to let your shadow plan your day'}
                    </p>
                    <button 
                        onClick={() => handleGeneratePlan(false)}
                        disabled={generating}
                        style={{
                            ...styles.generateButton,
                            opacity: generating ? 0.7 : 1,
                        }}
                        data-guide="generate-plan"
                    >
                        {generating ? (
                            <span style={styles.generatingText}>
                                <span style={styles.spinnerSmall}></span>
                                Generating...
                            </span>
                        ) : '‚ú® Generate My Plan'}
                    </button>
                </div>
            </div>
        );
    }

    const cards = plan.compressed_decision_cards || [];
    const pendingCount = cards.filter(c => cardStates[c.id]?.status === 'pending').length;
    const completedCount = cards.length - pendingCount;
    const allCompleted = pendingCount === 0 && cards.length > 0;

    return (
        <div style={themedContainer}>
            {/* Header */}
            <div style={styles.header}>
                <h3 style={themedTitle}>Today's Plan</h3>
                <button 
                    onClick={() => handleGeneratePlan(true)}
                    disabled={generating}
                    style={{
                        ...styles.regenerateButton,
                        backgroundColor: isDark ? currentTheme.backgroundSecondary : '#F3F4F6',
                    }}
                    title="Regenerate plan"
                >
                    {generating ? '...' : 'üîÑ'}
                </button>
            </div>

            {/* Progress indicator */}
            {cards.length > 0 && (
                <div style={styles.progress}>
                    <div style={{
                        ...styles.progressBar,
                        backgroundColor: isDark ? currentTheme.backgroundSecondary : '#E5E7EB',
                    }}>
                        <div 
                            style={{
                                ...styles.progressFill,
                                width: `${(completedCount / cards.length) * 100}%`,
                            }}
                        />
                    </div>
                    <span style={{...styles.progressText, color: currentTheme.textMuted}}>
                        {completedCount}/{cards.length} completed
                    </span>
                </div>
            )}

            {error && <p style={styles.error}>{error}</p>}

            {/* All completed celebration */}
            {allCompleted && (
                <div style={{
                    ...styles.celebration,
                    backgroundColor: isDark ? '#065F4622' : '#ECFDF5',
                }}>
                    <ShadowMascot state="celebrating" message="All done!" size="small" />
                    <p style={{...styles.celebrationText, color: currentTheme.textPrimary}}>You're all set for today!</p>
                    <p style={{...styles.celebrationHint, color: currentTheme.textMuted}}>Your shadow learned from your choices.</p>
                    <div style={styles.confetti}>
                        {['üéâ', '‚ú®', 'üåü', 'üí´', 'üéä'].map((emoji, i) => (
                            <span key={i} style={{
                                ...styles.confettiPiece,
                                animationDelay: `${i * 0.1}s`,
                                left: `${10 + i * 20}%`,
                            }}>{emoji}</span>
                        ))}
                    </div>
                </div>
            )}

            {/* Accept All button (show when cognitive load is high and multiple pending) */}
            {plan.autonomy_level === 'auto' && pendingCount > 1 && (
                <button 
                    onClick={handleAcceptAll}
                    style={styles.acceptAllButton}
                >
                    ‚úì Accept All ({pendingCount} cards)
                </button>
            )}

            {cards.length === 0 ? (
                <p style={{...styles.noCards, color: currentTheme.textMuted}}>No cards in this plan. Try adding more decisions!</p>
            ) : (
                <div style={styles.cardList}>
                    {cards.map((card, index) => {
                        const state = cardStates[card.id];
                        const isCompleted = state?.status === 'completed';
                        
                        return (
                            <div 
                                key={card.id || index} 
                                style={getCardStyle(card)}
                            >
                                {/* Completed badge */}
                                {isCompleted && (
                                    <div style={{
                                        ...styles.completedBadge,
                                        backgroundColor: state.action === 'accept' ? '#10B981' : 
                                                        state.action === 'override' ? '#F59E0B' : '#9CA3AF'
                                    }}>
                                        {state.action === 'accept' ? '‚úì Accepted' : 
                                         state.action === 'override' ? `‚Üª ${state.alternative || 'Changed'}` : 
                                         '‚úï Skipped'}
                                    </div>
                                )}

                                {/* Card Header */}
                                <div style={styles.cardHeader}>
                                    <span style={styles.cardEmoji}>{card.emoji || 'üìå'}</span>
                                    <span style={styles.cardTitle}>{card.title}</span>
                                    <span style={styles.cardDuration}>~{card.duration}min</span>
                                </div>

                                {/* Card Items */}
                                <div style={styles.cardItems}>
                                    {card.items?.map((item, i) => (
                                        <div key={i} style={styles.cardItem}>
                                            <span style={styles.itemIcon}>
                                                {item.type === 'task' ? '‚úì' : item.type === 'break' ? '‚òï' : 'üç¥'}
                                            </span>
                                            <span style={{
                                                ...styles.itemText,
                                                textDecoration: isCompleted && state.action !== 'ignore' ? 'line-through' : 'none',
                                                opacity: isCompleted ? 0.7 : 1,
                                            }}>
                                                {item.action}
                                            </span>
                                        </div>
                                    ))}
                                </div>

                                {/* Why Explanation */}
                                <div style={styles.whyBadge}>
                                    <span style={styles.whyIcon}>üí°</span>
                                    <span style={styles.whyText}>{card.why}</span>
                                </div>

                                {/* Action Buttons - only show if pending */}
                                {!isCompleted && (
                                    <div style={styles.cardActions} data-guide="card-actions">
                                        <button 
                                            style={styles.acceptButton}
                                            onClick={() => handleAccept(card)}
                                            title="Yes, this works for me!"
                                        >
                                            ‚úì Accept
                                        </button>
                                        <button 
                                            style={styles.overrideButton}
                                            onClick={() => handleOverride(card)}
                                            title="I prefer something else"
                                        >
                                            ‚Üª Override
                                        </button>
                                        <button 
                                            style={styles.ignoreButton}
                                            onClick={() => handleIgnore(card)}
                                            title="Skip for now"
                                        >
                                            ‚úï Skip
                                        </button>
                                    </div>
                                )}
                            </div>
                        );
                    })}
                </div>
            )}

            {/* Plan metadata */}
            <div style={styles.planMeta}>
                <span>Load: {plan.cognitive_load}</span>
                <span>‚Ä¢</span>
                <span>Mode: {plan.autonomy_level}</span>
            </div>

            {/* Override Modal */}
            {showOverrideModal && (
                <div style={styles.modalOverlay} onClick={() => setShowOverrideModal(false)}>
                    <div style={styles.modal} onClick={e => e.stopPropagation()}>
                        <h4 style={styles.modalTitle}>Choose Alternative</h4>
                        <p style={styles.modalSubtitle}>
                            What would you prefer instead of "{overrideCard?.title}"?
                        </p>
                        
                        <div style={styles.alternativesList}>
                            {alternatives.length === 0 ? (
                                <p style={styles.noAlternatives}>No other decisions available</p>
                            ) : (
                                alternatives.map(alt => (
                                    <div 
                                        key={alt.id}
                                        style={{
                                            ...styles.alternativeItem,
                                            backgroundColor: selectedAlternative?.id === alt.id ? '#EEF2FF' : 'white',
                                            borderColor: selectedAlternative?.id === alt.id ? '#4F46E5' : '#E5E7EB',
                                        }}
                                        onClick={() => setSelectedAlternative(alt)}
                                    >
                                        <span style={styles.altIcon}>
                                            {alt.type === 'task' ? 'üìã' : alt.type === 'meal' ? 'üç¥' : '‚òï'}
                                        </span>
                                        <div style={styles.altInfo}>
                                            <span style={styles.altTitle}>{alt.title}</span>
                                            <span style={styles.altType}>{alt.type}</span>
                                        </div>
                                        {selectedAlternative?.id === alt.id && (
                                            <span style={styles.checkmark}>‚úì</span>
                                        )}
                                    </div>
                                ))
                            )}
                        </div>
                        
                        <div style={styles.modalActions}>
                            <button 
                                style={styles.cancelButton}
                                onClick={() => {
                                    setShowOverrideModal(false);
                                    setSelectedAlternative(null);
                                }}
                            >
                                Cancel
                            </button>
                            <button 
                                style={{
                                    ...styles.confirmButton,
                                    opacity: selectedAlternative ? 1 : 0.5,
                                }}
                                disabled={!selectedAlternative}
                                onClick={confirmOverride}
                            >
                                Confirm Override
                            </button>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

const styles = {
    container: {
        backgroundColor: 'white',
        borderRadius: '12px',
        padding: '20px',
        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)',
    },
    header: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '12px',
    },
    title: {
        margin: 0,
        fontSize: '16px',
        fontWeight: '600',
        color: '#333',
    },
    regenerateButton: {
        padding: '6px 10px',
        backgroundColor: '#F3F4F6',
        border: 'none',
        borderRadius: '6px',
        cursor: 'pointer',
        fontSize: '14px',
        transition: 'all 0.2s',
    },
    progress: {
        marginBottom: '16px',
    },
    progressBar: {
        height: '6px',
        backgroundColor: '#E5E7EB',
        borderRadius: '3px',
        overflow: 'hidden',
        marginBottom: '4px',
    },
    progressFill: {
        height: '100%',
        backgroundColor: '#10B981',
        borderRadius: '3px',
        transition: 'width 0.3s ease',
    },
    progressText: {
        fontSize: '11px',
        color: '#6B7280',
    },
    loadingCard: {
        textAlign: 'center',
        padding: '30px',
        color: '#666',
    },
    spinner: {
        width: '24px',
        height: '24px',
        border: '3px solid #E5E7EB',
        borderTopColor: '#4F46E5',
        borderRadius: '50%',
        margin: '0 auto 12px',
        animation: 'spin 1s linear infinite',
    },
    emptyState: {
        textAlign: 'center',
        padding: '20px',
    },
    emptyIcon: {
        fontSize: '40px',
        display: 'block',
        marginBottom: '12px',
    },
    emptyText: {
        margin: '12px 0 4px 0',
        fontSize: '15px',
        color: '#374151',
        fontWeight: '500',
    },
    emptyHint: {
        margin: '0 0 16px 0',
        fontSize: '13px',
        color: '#6B7280',
    },
    generateButton: {
        padding: '14px 28px',
        background: 'linear-gradient(135deg, #4F46E5 0%, #7C3AED 100%)',
        color: 'white',
        border: 'none',
        borderRadius: '12px',
        fontSize: '15px',
        fontWeight: '600',
        cursor: 'pointer',
        transition: 'all 0.2s',
        boxShadow: '0 4px 15px rgba(79, 70, 229, 0.3)',
    },
    generatingText: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '10px',
    },
    spinnerSmall: {
        width: '16px',
        height: '16px',
        border: '2px solid rgba(255,255,255,0.3)',
        borderTopColor: 'white',
        borderRadius: '50%',
        animation: 'spin 0.8s linear infinite',
    },
    celebration: {
        textAlign: 'center',
        padding: '24px',
        background: 'linear-gradient(135deg, #ECFDF5 0%, #D1FAE5 100%)',
        borderRadius: '16px',
        marginBottom: '16px',
        position: 'relative',
        overflow: 'hidden',
    },
    celebrationText: {
        margin: '12px 0 4px 0',
        fontSize: '18px',
        fontWeight: '700',
        color: '#166534',
    },
    celebrationHint: {
        margin: 0,
        fontSize: '13px',
        color: '#15803D',
    },
    confetti: {
        position: 'absolute',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        pointerEvents: 'none',
        overflow: 'hidden',
    },
    confettiPiece: {
        position: 'absolute',
        top: '-20px',
        fontSize: '20px',
        animation: 'confetti-fall 2s ease-in-out infinite',
    },
    acceptAllButton: {
        width: '100%',
        padding: '12px',
        backgroundColor: '#10B981',
        color: 'white',
        border: 'none',
        borderRadius: '8px',
        fontSize: '14px',
        fontWeight: '600',
        cursor: 'pointer',
        marginBottom: '16px',
    },
    error: {
        backgroundColor: '#FEE2E2',
        color: '#DC2626',
        padding: '8px 12px',
        borderRadius: '6px',
        fontSize: '13px',
        marginBottom: '12px',
    },
    noCards: {
        textAlign: 'center',
        color: '#6B7280',
        fontSize: '14px',
        padding: '20px',
    },
    cardList: {
        display: 'flex',
        flexDirection: 'column',
        gap: '12px',
    },
    card: {
        backgroundColor: '#FAFAFA',
        borderRadius: '10px',
        padding: '16px',
        borderLeft: '4px solid #4F46E5',
        transition: 'all 0.3s ease',
        position: 'relative',
    },
    cardCompleted: {
        transform: 'scale(0.98)',
    },
    completedBadge: {
        position: 'absolute',
        top: '8px',
        right: '8px',
        padding: '4px 8px',
        borderRadius: '4px',
        fontSize: '10px',
        fontWeight: '600',
        color: 'white',
    },
    cardHeader: {
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
        marginBottom: '12px',
    },
    cardEmoji: {
        fontSize: '20px',
    },
    cardTitle: {
        flex: 1,
        fontSize: '15px',
        fontWeight: '600',
        color: '#1F2937',
    },
    cardDuration: {
        fontSize: '12px',
        color: '#6B7280',
        backgroundColor: '#E5E7EB',
        padding: '2px 8px',
        borderRadius: '10px',
    },
    cardItems: {
        display: 'flex',
        flexDirection: 'column',
        gap: '6px',
        marginBottom: '12px',
    },
    cardItem: {
        display: 'flex',
        alignItems: 'center',
        gap: '8px',
        fontSize: '14px',
        color: '#374151',
    },
    itemIcon: {
        width: '18px',
        textAlign: 'center',
        color: '#6B7280',
    },
    itemText: {
        flex: 1,
        transition: 'all 0.2s',
    },
    whyBadge: {
        display: 'flex',
        alignItems: 'flex-start',
        gap: '6px',
        backgroundColor: '#EEF2FF',
        padding: '8px 10px',
        borderRadius: '6px',
        marginBottom: '12px',
    },
    whyIcon: {
        fontSize: '12px',
    },
    whyText: {
        fontSize: '12px',
        color: '#4338CA',
        fontStyle: 'italic',
        lineHeight: '1.4',
    },
    cardActions: {
        display: 'flex',
        gap: '8px',
    },
    acceptButton: {
        flex: 1,
        padding: '10px',
        backgroundColor: '#10B981',
        color: 'white',
        border: 'none',
        borderRadius: '6px',
        fontSize: '13px',
        fontWeight: '600',
        cursor: 'pointer',
        transition: 'all 0.2s',
    },
    overrideButton: {
        flex: 1,
        padding: '10px',
        backgroundColor: '#F59E0B',
        color: 'white',
        border: 'none',
        borderRadius: '6px',
        fontSize: '13px',
        fontWeight: '600',
        cursor: 'pointer',
        transition: 'all 0.2s',
    },
    ignoreButton: {
        flex: 1,
        padding: '10px',
        backgroundColor: '#6B7280',
        color: 'white',
        border: 'none',
        borderRadius: '6px',
        fontSize: '13px',
        fontWeight: '600',
        cursor: 'pointer',
        transition: 'all 0.2s',
    },
    planMeta: {
        display: 'flex',
        justifyContent: 'center',
        gap: '8px',
        marginTop: '16px',
        fontSize: '11px',
        color: '#9CA3AF',
    },
    // Modal styles
    modalOverlay: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
    },
    modal: {
        backgroundColor: 'white',
        borderRadius: '12px',
        padding: '24px',
        width: '90%',
        maxWidth: '400px',
        maxHeight: '80vh',
        overflow: 'auto',
    },
    modalTitle: {
        margin: '0 0 4px 0',
        fontSize: '18px',
        fontWeight: '600',
        color: '#1F2937',
    },
    modalSubtitle: {
        margin: '0 0 16px 0',
        fontSize: '14px',
        color: '#6B7280',
    },
    alternativesList: {
        display: 'flex',
        flexDirection: 'column',
        gap: '8px',
        marginBottom: '20px',
        maxHeight: '300px',
        overflow: 'auto',
    },
    noAlternatives: {
        textAlign: 'center',
        color: '#6B7280',
        fontSize: '14px',
        padding: '20px',
    },
    alternativeItem: {
        display: 'flex',
        alignItems: 'center',
        gap: '12px',
        padding: '12px',
        borderRadius: '8px',
        border: '2px solid #E5E7EB',
        cursor: 'pointer',
        transition: 'all 0.2s',
    },
    altIcon: {
        fontSize: '20px',
    },
    altInfo: {
        flex: 1,
    },
    altTitle: {
        display: 'block',
        fontSize: '14px',
        fontWeight: '500',
        color: '#1F2937',
    },
    altType: {
        display: 'block',
        fontSize: '12px',
        color: '#6B7280',
        textTransform: 'capitalize',
    },
    checkmark: {
        color: '#4F46E5',
        fontWeight: 'bold',
    },
    modalActions: {
        display: 'flex',
        gap: '12px',
    },
    cancelButton: {
        flex: 1,
        padding: '12px',
        backgroundColor: '#F3F4F6',
        color: '#374151',
        border: 'none',
        borderRadius: '8px',
        fontSize: '14px',
        fontWeight: '500',
        cursor: 'pointer',
    },
    confirmButton: {
        flex: 1,
        padding: '12px',
        backgroundColor: '#F59E0B',
        color: 'white',
        border: 'none',
        borderRadius: '8px',
        fontSize: '14px',
        fontWeight: '600',
        cursor: 'pointer',
        transition: 'opacity 0.2s',
    },
};

// Add keyframe animations
const styleSheet = document.createElement('style');
styleSheet.textContent = `
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    @keyframes confetti-fall {
        0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
        100% { transform: translateY(150px) rotate(360deg); opacity: 0; }
    }
    
    @keyframes card-appear {
        from { 
            opacity: 0; 
            transform: translateY(-10px) scale(0.95); 
        }
        to { 
            opacity: 1; 
            transform: translateY(0) scale(1); 
        }
    }
    
    @keyframes card-complete {
        0% { transform: scale(1); }
        50% { transform: scale(1.02); }
        100% { transform: scale(0.98); }
    }
    
    @keyframes pulse-ring {
        0% { transform: scale(1); opacity: 1; }
        100% { transform: scale(1.5); opacity: 0; }
    }
    
    .card-animate {
        animation: card-appear 0.3s ease-out forwards;
    }
    
    .card-complete-animate {
        animation: card-complete 0.3s ease-out forwards;
    }
    
    .generate-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(79, 70, 229, 0.4);
    }
    
    .generate-btn:active {
        transform: translateY(0);
    }
`;
document.head.appendChild(styleSheet);

export default DecisionCards;
